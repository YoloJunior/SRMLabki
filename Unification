import re
from collections import deque

class Predicate:
    def __init__(self, name, args):
        self.name = name
        self.args = args  # Список аргументів

    def __str__(self):
        return f"{self.name}({', '.join(self.args)})"

def parse_predicate(predicate_str):
    pattern = r'(\w+)\((.*)\)'
    match = re.match(pattern, predicate_str.strip())
    if not match:
        raise ValueError(f"Неправильний формат предиката: {predicate_str}")
    name = match.group(1)
    args = [arg.strip() for arg in match.group(2).split(',')]
    return Predicate(name, args)

def is_variable(term):
    return re.match(r'^[a-z]$', term) is not None

def unify(pred1, pred2):
    print("Початок уніфікації...")
    print(f"Предикат 1: {pred1}")
    print(f"Предикат 2: {pred2}\n")

    if pred1.name != pred2.name:
        print(f"Імена предикатів різні: {pred1.name} ≠ {pred2.name}. Уніфікація неможлива.")
        return None
    if len(pred1.args) != len(pred2.args):
        print(f"Кількість аргументів різна: {len(pred1.args)} ≠ {len(pred2.args)}. Уніфікація неможлива.")
        return None

    substitutions = {}
    pairs = deque(zip(pred1.args, pred2.args))
    step = 1

    while pairs:
        s, t = pairs.popleft()
        print(f"Крок {step}:")
        print(f"  Порівнюємо: {s} та {t}")

        s = apply_substitutions(s, substitutions)
        t = apply_substitutions(t, substitutions)

        print(f"  Після застосування підстановок: {s} та {t}")

        if s == t:
            print("  Терміни однакові. Переходимо до наступного кроку.\n")
            step += 1
            continue
        elif is_variable(s):
            if occurs_check(s, t, substitutions):
                print(f"  Перевірка на циклічність: {s} міститься в {t}. Уніфікація неможлива.\n")
                return None
            substitutions[s] = t
            print(f"  Змінна {s} підставляється значенням {t}.")
            # Застосовуємо нову підстановку до всіх попередніх пар
            new_pairs = []
            for (a, b) in pairs:
                a_new = apply_substitutions(a, substitutions)
                b_new = apply_substitutions(b, substitutions)
                new_pairs.append((a_new, b_new))
            pairs = deque(new_pairs)
            print(f"  Поточні підстановки: {substitutions}\n")
            step += 1
        elif is_variable(t):
            if occurs_check(t, s, substitutions):
                print(f"  Перевірка на циклічність: {t} міститься в {s}. Уніфікація неможлива.\n")
                return None
            substitutions[t] = s
            print(f"  Змінна {t} підставляється значенням {s}.")
            # Застосовуємо нову підстановку до всіх попередніх пар
            new_pairs = []
            for (a, b) in pairs:
                a_new = apply_substitutions(a, substitutions)
                b_new = apply_substitutions(b, substitutions)
                new_pairs.append((a_new, b_new))
            pairs = deque(new_pairs)
            print(f"  Поточні підстановки: {substitutions}\n")
            step += 1
        else:
            # Якщо обидва терміни функції, треба розібрати їх
            if '(' in s and ')' in s:
                s_pred = parse_predicate(s)
            else:
                s_pred = Predicate(s, [])
            if '(' in t and ')' in t:
                t_pred = parse_predicate(t)
            else:
                t_pred = Predicate(t, [])

            print(f"  Обидва терміни є предикатами: {s_pred} та {t_pred}")

            if s_pred.name != t_pred.name or len(s_pred.args) != len(t_pred.args):
                print(f"  Імена або кількість аргументів різні: {s_pred} ≠ {t_pred}. Уніфікація неможлива.\n")
                return None

            # Додаємо аргументи для уніфікації
            for arg_s, arg_t in zip(s_pred.args, t_pred.args):
                pairs.appendleft((arg_s, arg_t))
            print(f"  Додаємо аргументи {s_pred.args} та {t_pred.args} для уніфікації.\n")
            step += 1

    print("Уніфікація успішна.")
    return substitutions

def apply_substitutions(term, substitutions):
    while term in substitutions:
        term = substitutions[term]
    return term

def occurs_check(var, term, substitutions):
    if var == term:
        return True
    elif is_variable(term) and term in substitutions:
        return occurs_check(var, substitutions[term], substitutions)
    return False

def apply_substitution_to_predicate(predicate, substitutions):
    new_args = [apply_substitutions(arg, substitutions) for arg in predicate.args]
    return Predicate(predicate.name, new_args)

def main():
    # Вхідні предикати
    pred_str1 = "P(f(a), g(x))"
    pred_str2 = "P(y, y)"

    pred1 = parse_predicate(pred_str1)
    pred2 = parse_predicate(pred_str2)

    substitutions = unify(pred1, pred2)

    if substitutions is not None:
        print("Уніфікатор:")
        for var, val in substitutions.items():
            print(f"  {var} → {val}")
        unified_pred1 = apply_substitution_to_predicate(pred1, substitutions)
        unified_pred2 = apply_substitution_to_predicate(pred2, substitutions)
        print(f"\nРезультуючий предикат 1: {unified_pred1}")
        print(f"Результуючий предикат 2: {unified_pred2}")
    else:
        print("\nУніфікація неможлива.")

if __name__ == "__main__":
    main()

